*==========================================================================
*
*	128 枚モード・ソーティングルーチン
*
*==========================================================================

					; a0.l = 書換用バッファ管理構造体
	movea.l	div_buff(a0),a1		; a1.l = #ラスタ分割バッファA

					;---------------------------------------
					; d0.l = 
					; d1.l = 
					; d2.w = 
					; d3.w = 
					; d4.w = 
					; d5.w = 
					; d6.l = 
					; d7.w = 連鎖数 dbcc カウンタ
					;---------------------------------------
					; a0.l = 仮バッファスキャン & チェインスキャン
					; a1.l = 転送先スキャン
					; a2.l = 
					; a3.l = 
					; a4.l = 
					; a5.l = 
					; a6.l = 
					; a7.l = チェイン先頭情報
					;---------------------------------------

	move.l	(a7)+,a0		; PR ごとの先頭アドレス
	move.w	CHAIN_OFS(a0),d7	; 連鎖数（そのまま dbcc カウンタとして使える）
	bmi.b	SORT_128_END		; いきなり連鎖数が負（終点）なら終了

*-------[ ソーティング処理ループ ]
SORT_128_LOOP_:				; ループ 2 倍展開
	asr.w	#1,d7
	bcc.b	.sort_128_skip_first2	; 奇数要素数の場合は 1 個スキップ

SORT_128_LOOP:
	move.l	(a0)+,(a1)+		; x,y 転送
	move.l	(a0)+,(a1)+		; cd,pr 転送
.sort_128_skip_first2:
	move.l	(a0)+,(a1)+		; x,y 転送
	move.l	(a0)+,(a1)+		; cd,pr 転送
	dbra	d7,SORT_128_LOOP

	movea.l	CHAIN_OFS-4(a0),a0	; 次の PR 鎖アドレス
	move.w	CHAIN_OFS(a0),d7	; 連鎖数（そのまま dbcc カウンタとして使える）
	bpl.b	SORT_128_LOOP_		; 連鎖数 >= 0 なら続行

	;-------[ PR 変更 ]
		move.l	(a7)+,a0		; 次の PR の先頭アドレス
		move.w	CHAIN_OFS(a0),d7	; 連鎖数（そのまま dbcc カウンタとして使える）
		bpl.b	SORT_128_LOOP_		; 連鎖数 >= 0 なら続行

SORT_128_END:


*--------------------------------------------------------------------------
*
*	最大 128 枚モード ソート後処理
*
*--------------------------------------------------------------------------

	move.l	write_struct(pc),a0		; a0.l = 書換用バッファ管理構造体
	suba.l	div_buff(a0),a1			; a1.l = 使用スプライト数 x 8
	move.w	a1,d0
	move.w	d0,buff_sp_total(a0)		; バッファナンバー別 スプライト数 x 8 改めて保存




